---
title: "Proyecto estadística"
author: "María de los Ángeles Díaz Castro, Florencia Pellegrini, Iyán Álvarez Rodriguez, Azahara Martinez Moraño"
date: "2025-12-01"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(readr)
library(forecast)   
library(tseries)    
library(ggplot2)
library(gridExtra)
library(dplyr)
library(jsonlite)

datos <- read_csv("stock_returns_train.csv")
```

# 1. Planteamiento
**Tu equipo ha decidido invertir en un portafolio con 5 activos. Cuentas con un historico de rendimientos ri t para t = 1,...,T y i = 1,...,5 . Quieres usar este histórico para decidir como repartiras tu inversión inicial I0 en los 5 activos. Es decir que quieres decidir sobre los valores αi t con αi t = 1 para t = T+1,...,T + r, en función del rendimiento que esperas de cada activo para el proximo periodo y de una funci´on de utilidad que describe tus preferencias.**

# Predicción de rendimientos
**1. Obten un modelo pronósticos para Xi tXi 0,...,Xt − 1i para i = 1,2,...,5. Utilizando los datos Xtrain como consideres apropiado.**

**2. Obten tanto el valor esperado del pronóstico E[Xi tXi 0,...,Xt − 1i] como la varianza V [Xi tXi 0,...,Xt − 1i].**


**3. en cada momento t = T +1,...,T +r podras utilizar todo el pasado de la serie como 1,...,t − 1 de la forma que consideres adecuado para realizar tu pronostico.**

**4. No veras el periodo de valuación t = T+1,...,T+r hasta después de entregar el proyecto por lo que debes generar un funci´on oneStepAhead(X1:t,Mθ))... return ˆ Xt+1). Es decir que toma el pasado de las 5 series, los modelos de predicción de las 5 series y que regresa un el pronostico a un paso (valor esperado y varianza) de los 5 activos**

1)
```{r}
# Seleccionar 5 primeras columnas numéricas
num_cols <- names(datos)[sapply(datos, is.numeric)]
assets   <- num_cols[1:5]
assets
```

```{r}
# Ajustar modelo ARIMA para cada activo usando TODO el X_train
modelos <- list()

for (asset in assets) {
  serie <- na.omit(datos[[asset]])
  
  # Transformamos la serie a una serie temporal
  serie_ts <- ts(serie)
  
  #Aplicamos la función autoarima
  mod <- auto.arima(serie_ts, stepwise = FALSE,approximation = FALSE)
  
  modelos[[asset]] <- mod
  
  cat("\nModelo para", asset, ":\n")
  print(mod)
}

```


4) Vemos conveniente la realización de la función oneStepAhead, para responder al segundo apartado.


```{r}
oneStepAhead <- function(X_past, modelos) {
  mu  <- numeric(length(modelos))
  sig2 <- numeric(length(modelos))
  
  names(mu)   <- names(modelos)
  names(sig2) <- names(modelos)
  
  for (asset in names(modelos)) {
    serie <- as.numeric(na.omit(X_past[[asset]]))
    serie_ts <- ts(serie)
    
    # Actualizamos usando TODO el pasado disponible
    mod_upd <- Arima(serie_ts, model = modelos[[asset]])
    
    fc <- forecast(mod_upd, h = 1)
    
    mu[asset]   <- as.numeric(fc$mean[1])           # E[X_{t+1} | pasado]
    sig2[asset] <- as.numeric(mod_upd[["sigma2"]]) # Varianza del modelo
  }
  
  return(list(mean = mu, var = sig2))
}

```

```{r}
oneStepAhead( datos[, assets],modelos)
```

