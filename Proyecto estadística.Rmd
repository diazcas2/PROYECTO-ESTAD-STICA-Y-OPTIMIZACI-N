---
title: "Proyecto estadística"
author: "María de los Ángeles Díaz Castro, Florencia Pellegrini, Iyán Álvarez Rodriguez, Azahara Martinez Moraño"
date: "2025-12-01"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(readr)
library(forecast)   
library(tseries)    
library(ggplot2)
library(gridExtra)
library(dplyr)
library(jsonlite)

datos <- read_csv("stock_returns_train.csv")
```

# 1. Planteamiento
**Tu equipo ha decidido invertir en un portafolio con 5 activos. Cuentas con un historico de rendimientos ri t para t = 1,...,T y i = 1,...,5 . Quieres usar este histórico para decidir como repartiras tu inversión inicial I0 en los 5 activos. Es decir que quieres decidir sobre los valores αi t con αi t = 1 para t = T+1,...,T + r, en función del rendimiento que esperas de cada activo para el proximo periodo y de una funci´on de utilidad que describe tus preferencias.**

# 2. Predicción de rendimientos
**1. Obten un modelo pronósticos para Xi tXi 0,...,Xt − 1i para i = 1,2,...,5. Utilizando los datos Xtrain como consideres apropiado.**
**2. Obten tanto el valor esperado del pronóstico E[Xi tXi 0,...,Xt − 1i] como la varianza V [Xi tXi 0,...,Xt − 1i].**

**3. en cada momento t = T +1,...,T +r podras utilizar todo el pasado de la serie como 1,...,t − 1 de la forma que consideres adecuado para realizar tu pronostico.**

**4. No veras el periodo de valuación t = T+1,...,T+r hasta después de entregar el proyecto por lo que debes generar un funci´on oneStepAhead(X1:t,Mθ))... return ˆ Xt+1). Es decir que toma el pasado de las 5 series, los modelos de predicción de las 5 series y que regresa un el pronostico a un paso (valor esperado y varianza) de los 5 activos**

1)
```{r}
# Seleccionar 5 primeras columnas numéricas
num_cols <- names(datos)[sapply(datos, is.numeric)]
assets   <- num_cols[1:5]
assets
```

```{r}
# Ajustar modelo ARIMA para cada activo usando TODO el X_train
modelos <- list()

for (asset in assets) {
  serie <- na.omit(datos[[asset]])
  
  # Transformamos la serie a una serie temporal
  serie_ts <- ts(serie)
  
  #Aplicamos la función autoarima
  mod <- auto.arima(serie_ts, stepwise = FALSE,approximation = FALSE)
  
  modelos[[asset]] <- mod
  
  cat("\nModelo para", asset, ":\n")
  print(mod)
}

```

```{r}
oneStepAhead <- function(X_past, modelos) {
  mu  <- numeric(length(modelos))
  sig2 <- numeric(length(modelos))
  
  names(mu)   <- names(modelos)
  names(sig2) <- names(modelos)
  
  for (asset in names(modelos)) {
    serie <- as.numeric(na.omit(X_past[[asset]]))
    serie_ts <- ts(serie)
    
    # Actualizamos usando TODO el pasado disponible
    mod_upd <- Arima(serie_ts, model = modelos[[asset]])
    
    fc <- forecast(mod_upd, h = 1)
    
    mu[asset]   <- as.numeric(fc$mean[1])           # E[X_{t+1} | pasado]
    sig2[asset] <- as.numeric(mod_upd[["sigma2"]]) # Varianza del modelo
  }
  
  return(list(mean = mu, var = sig2))
}

```

```{r}
mod_mv<-oneStepAhead( datos[, assets],modelos)
mod_mv
```

Recordemos que el Modelo 1 es un ARIMA(0,0,0) y nos llama la atención el resultado obtenido por tener media 0 y varianza finita, lo que concuerda con el ruido blanco, .

En resumen: 
```{r}
cat('El valor esperado del modelo X1:', mean(mod_mv$mean[1],na.rm = TRUE))
cat('La varianza del modelo X1:', mean(mod_mv$var[1],na.rm = TRUE))

cat('El valor esperado del modelo X2:', mean(mod_mv$mean[2],na.rm = TRUE))
cat('La varianza del modelo X2:', mean(mod_mv$var[2],na.rm = TRUE))


cat('El valor esperado del modelo X3:', mean(mod_mv$mean[3],na.rm = TRUE))
cat('La varianza del modelo X3:', mean(mod_mv$var[3],na.rm = TRUE))

cat('El valor esperado del modelo X4:', mean(mod_mv$mean[4],na.rm = TRUE))
cat('La varianza del modelo X4:', mean(mod_mv$var[4],na.rm = TRUE))


cat('El valor esperado del modelo X5:', mean(mod_mv$mean[5],na.rm = TRUE))
cat('La varianza del modelo X5:', mean(mod_mv$var[5],na.rm = TRUE))
```

Por otro lado, para que al incorporar los datos reales podamos realizar todas las predicciones mediante el enfoque one step ahead, vamos a crear una función que se actualice progresivamente a medida que se dispone de nueva información, incorporando los valores reales que inicialmente no conocemos.

```{r}
oneStepAhead_mod <- function(X_past, X_reales, modelos, k) {
  
  # lista donde guardamos los pronósticos
  preds <- vector("list", k)
  means_list <- vector("list", k)
  vars_list  <- vector("list", k)
  
  for (i in 1:k) {
    
    # 1. pronóstico one-step-ahead
    pred <- oneStepAhead(X_past, modelos)
    
    # guardar predicción
    preds[[i]] <- pred$mean
    means_list[[i]] <- pred$mean
    vars_list[[i]]  <- pred$var
    
    # 2. añadir la observación real siguiente (una fila)
    # X_reales debe ser un data frame con 5 columnas
    X_past <- rbind(X_past, X_reales[i, ])
  }
  
  # devolver matriz k x 5 de predicciones
  preds_matrix <- do.call(rbind, preds)
  rownames(preds_matrix) <- paste0("t+", 1:k)
  means_matrix <- do.call(rbind, means_list)
  vars_matrix  <- do.call(rbind, vars_list)
   rownames(means_matrix) <- paste0("t+", 1:k)
  rownames(vars_matrix)  <- paste0("t+", 1:k)
  
  return(list(preds_matrix,means = means_matrix,
    vars  = vars_matrix))
}

```

Comprobación de la función usando $X_{TRAIN}$ y $X_{TEST}$:

```{r}
N <- nrow(datos)
prop_test <- 0.2

# número de datos para test
r <- round(N * prop_test)

# número de datos para train
T_train <- N - r

X_train <- datos[1:T_train, ]
X_test <- datos[(T_train + 1):N, ]

cat("Tamaño X_train:", nrow(X_train), "\n")
cat("Tamaño X_test:", nrow(X_test), "\n")

```

```{r}
oneStepAhead_mod(X_train,X_test,modelos,k=24)
```




# Utilidad Media-Varianza

**1. Obtener αt para t = T +1,...,T +r optimizando UMV. Elegir γ y estimar Σt tomando en cuenta que evaluara el rendimiento total en un periodo de prueba. Se permite tomar posiciones cortas**

**2. Repetir pero ahora prohibiendo posiciones cortas.**

```{r}
construccion_sigma_t<-function(var,datos){
  diagonal_sigmas <- sqrt(var)
  D <- diag(diagonal_sigmas)
  R <- cor(datos)
  
  # Reconstruir la Matriz de Covarianzas Sigma_t
  sigma_t <- D %*% R %*% D
  return(sigma_t)
}
```


```{r}
#Tenemos que fijar gamma, que es la aversión al riesgo. 
# Valores más altos implican mayor aversión al riesgo (no quieres arriesgar tanto)

UMV <- function(datos, alfat, gamma, mu, var_vector) {
  sigma_t<-construccion_1sigma_t(var_vector,datos)
  
  # 2. CALCULAR EL RENDIMIENTO ESPERADO DEL PORTAFOLIO (E[Rp])
  E_Rp <- t(alfat) %*% mu
  
  
  # 3. CALCULAR LA VARIANZA DEL PORTAFOLIO (Var[Rp])
  Var_Rp <- t(alfat) %*% sigma_t %*% alfat
  
  
  # 4. CALCULAR LA UTILIDAD ESPERADA (U)
  U <- E_Rp - (1/2) * gamma * Var_Rp
  
  return(as.numeric(U))
}
```

```{r}
posiciones_cortas <- function(mu, Sigma_t, gamma) {
  # mu: vector de medias (mod_mv$mean)
  # Sigma_t: matriz de covarianzas
  # gamma: aversión al riesgo (>0)
  
  n <- length(mu)
  uno <- rep(1, n)
  
  Sigma_inv <- solve(Sigma_t)
  
  # Escalares A y B
  A <- as.numeric(t(uno) %*% Sigma_inv %*% uno)
  B <- as.numeric(t(uno) %*% Sigma_inv %*% mu)
  
  # Parte sin restricción
  parte_mu <- (1 / gamma) * (Sigma_inv %*% mu)         # vector n×1
  
  # Lagrange λ como escalar
  lambda <- (B - gamma) / (gamma * A)                  # escalar
  
  # Ajuste por restricción de suma 1
  parte_restriccion <- lambda * (Sigma_inv %*% uno)    # vector n×1
  
  alpha_optimo <- parte_mu - parte_restriccion         # vector n×1
  
  return(as.numeric(alpha_optimo))
}

```

```{r}
s<-posiciones_cortas(
  mu = mod_mv$mean,
  Sigma_t = construccion_sigma_t(mod_mv$var,datos),
  gamma = 5
)

names(s)<-paste0('alfa',seq(1,5))
cat("Los alfa óptimos para cada modelo son:\n")
print(s)

#Lo comprobamos:
sum(s)
```

```{r}
sin_posiciones_cortas<-function(){
  
}
```

