---
title: "Proyecto estadística"
author: "María de los Ángeles Díaz Castro, Florencia Pellegrini, Iyán Álvarez Rodriguez, Azahara Martinez Moraño"
date: "2025-12-01"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(readr)
library(forecast)   
library(tseries)    
library(ggplot2)
library(gridExtra)
library(dplyr)
library(jsonlite)

datos <- read_csv("stock_returns_train_2.csv")
```

# 1. Planteamiento
**Tu equipo ha decidido invertir en un portafolio con 5 activos. Cuentas con un historico de rendimientos ri t para t = 1,...,T y i = 1,...,5 . Quieres usar este histórico para decidir como repartiras tu inversión inicial I0 en los 5 activos. Es decir que quieres decidir sobre los valores αi t con αi t = 1 para t = T+1,...,T + r, en función del rendimiento que esperas de cada activo para el proximo periodo y de una funci´on de utilidad que describe tus preferencias.**

# 2. Predicción de rendimientos
**1. Obten un modelo pronósticos para Xi tXi 0,...,Xt − 1i para i = 1,2,...,5. Utilizando los datos Xtrain como consideres apropiado.**
**2. Obten tanto el valor esperado del pronóstico E[Xi tXi 0,...,Xt − 1i] como la varianza V [Xi tXi 0,...,Xt − 1i].**

**3. en cada momento t = T +1,...,T +r podras utilizar todo el pasado de la serie como 1,...,t − 1 de la forma que consideres adecuado para realizar tu pronostico.**

**4. No veras el periodo de valuación t = T+1,...,T+r hasta después de entregar el proyecto por lo que debes generar un funci´on oneStepAhead(X1:t,Mθ))... return ˆ Xt+1). Es decir que toma el pasado de las 5 series, los modelos de predicción de las 5 series y que regresa un el pronostico a un paso (valor esperado y varianza) de los 5 activos**

1)

```{r}
oneStepAhead <- function(x_train, x_test_past) {
  
  # Convertimos a vector numérico limpio
  x_train <- as.numeric(na.omit(x_train))
  x_test_past <- as.numeric(na.omit(x_test_past))

  if (length(x_test_past) == 0) {
    x_past <- x_train
  } else {
    x_past <- c(x_train, x_test_past)
  }
  
  # 1. Ajustamos ARIMA al histórico
  mod <- auto.arima(x_train, stepwise = FALSE, approximation = FALSE)
  
  # 2. Actualizamos el modelo
  fit_upd <- Arima(x_past, model = mod)
  
  # 3. Forecast one-step-ahead
  fc <- forecast(fit_upd, h = 1)
  mu_hat <- as.numeric(fc$mean[1])
  
  # 4. Estimamos el error estándar usando intervalo 80%
  z80 <- qnorm(0.8)
  se_from_up <- (fc$upper[,"80%"][1] - fc$mean[1]) / z80
  se_from_lo <- (fc$mean[1] - fc$lower[,"80%"][1]) / z80
  se_hat <- as.numeric(max(se_from_up, se_from_lo))
  
  return(list(mu_hat = mu_hat, se_hat = se_hat))
}


```

Comprobación de la función usando $X_{TRAIN}$ y $X_{TEST}$:

```{r}
N <- nrow(datos)
prop_test <- 0.2

# número de datos para test
r <- round(N * prop_test)

# número de datos para train
T_train <- N - r

X_train <- datos[1:T_train, ]
X_test <- datos[(T_train + 1):N, ]

cat("Tamaño X_train:", nrow(X_train), "\n")
cat("Tamaño X_test:", nrow(X_test), "\n")

```

```{r}
mod_mod<-oneStepAhead(X_train,X_test)
mod_mod
```

# Utilidad Media-Varianza

**1. Obtener αt para t = T +1,...,T +r optimizando UMV. Elegir γ y estimar Σt tomando en cuenta que evaluara el rendimiento total en un periodo de prueba. Se permite tomar posiciones cortas**

**2. Repetir pero ahora prohibiendo posiciones cortas.**

```{r}
construccion_sigma_t <- function(sig, Xpast){
  # 1. Matriz diagonal de desviaciones estándar
  D <- diag(sig)
  
  # 2. Matriz de correlaciones históricas
  R <- cor(Xpast, use = "pairwise.complete.obs")
  
  # 3. Construcción de la matriz de covarianza
  Sigma <- D %*% R %*% D
  
  return(Sigma)
}
```


```{r}
posiciones_cortas <- function(mu, Sigma, gamma){
  N <- length(mu)
  uno <- matrix(1, nrow = 1, ncol = N)
  mu <- matrix(mu, ncol = 1)
  
  # Inversa de Sigma
  Sigma_inv <- solve(Sigma)
  
  # Cálculo de lambda_star para la restricción sum(alpha)=1
  A <- as.numeric(uno %*% Sigma_inv %*% t(uno))
  B <- as.numeric(uno %*% Sigma_inv %*% mu)
  lambda_star <- (B - gamma) / A
  
  # Cálculo de alpha
  parte_mu <- (1 / gamma) * (Sigma_inv %*% mu)
  parte_restriccion <- Sigma_inv %*% t(uno) * (lambda_star / gamma)
  alpha <- parte_mu - parte_restriccion
  
  alpha_vec <- as.numeric(alpha)
  names(alpha_vec) <- paste0("alpha_", 1:N)
  
  
  return(alpha_vec)
}


```

```{r}
# Supongamos que ya tienes X_train, X_test y modelos ajustados
mu=mod_mod$mu_hat
var=mod_mod$se_hat
sd=sqrt(var)
Sigma=construccion_sigma_t(sd,datos)

alphas_optimos <- posiciones_cortas(mu,Sigma,gamma=5)
# Mostrar resultados
print(alphas_optimos)
sum(alphas_optimos)

```

```{r}
library(quadprog)
sin_posiciones_cortas  <- function(mu, Sigma, gamma){
  N <- length(mu)
  
  # Definir parámetros para solve.QP
  Dmat <- gamma * Sigma
  dvec <- mu
  Aeq <- matrix(1, nrow = N, ncol = 1)
  G <- diag(N)
  Amat <- cbind(Aeq, G)
  bvec <- c(1, rep(0, N))
  
  # Resolver problema de optimización cuadrática
  sol <- quadprog::solve.QP(Dmat, dvec, Amat, bvec, meq = 1)
  
  # Ajustes finales: redondear y eliminar negativos
  alpha_vec <- round(sol$solution, 8)
  alpha_vec[alpha_vec < 0] <- 0
  names(alpha_vec) <- paste0("alpha_", 1:N)
  
  return(alpha_vec)
}
```


```{r}
alphas_sin_cortos <- sin_posiciones_cortas(mu,Sigma,gamma = 5)

print(alphas_sin_cortos)
sum(alphas_sin_cortos)
alphas_sin_cortos < 0

```


# Log-utilidad

**1. Obtener αt para t = T +1,...,T +r optimizando Ulog. Se permite tomar posiciones cortas y no enteras.**

```{r}
getAlphaLog <- function(mu, Sigma, gamma){
  N <- length(mu)
  
  # Transformación softmax para imponer suma=1
  softmax <- function(z){
    e <- exp(z - max(z))
    return(e / sum(e))
  }
  
  # Función objetivo sobre z (no sobre alpha directamente)
  f_obj <- function(z){
    alpha <- softmax(z)
    muTalpha <- sum(alpha * mu)
    alphaTSigmaAlpha <- t(alpha) %*% Sigma %*% alpha
    
    Ulog <- log(1 + muTalpha) -
      (gamma/2) * alphaTSigmaAlpha / (1 + muTalpha)^2
    
    return(-Ulog)
  }
  
  # inicialización
  z0 <- rep(0, N)
  
  sol <- optim(par = z0, fn = f_obj, method="BFGS")
  
  alpha <- softmax(sol$par)
  names(alpha) <- paste0("alpha_Log_", 1:N)
  return(alpha)
}


```


```{r}
beta<-getAlphaLog(mu,Sigma,gamma=6)
print(beta)
sum(beta)
```

