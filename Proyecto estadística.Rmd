---
title: "Proyecto estadística"
author: "María de los Ángeles Díaz Castro, Florencia Pellegrini, Iyán Álvarez Rodriguez, Azahara Martinez Moraño"
date: "2025-12-01"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(readr)
library(forecast)   
library(tseries)    
library(ggplot2)
library(gridExtra)
library(dplyr)
library(jsonlite)

datos <- read_csv("stock_returns_train.csv")
```

# 1. Planteamiento
**Tu equipo ha decidido invertir en un portafolio con 5 activos. Cuentas con un historico de rendimientos ri t para t = 1,...,T y i = 1,...,5 . Quieres usar este histórico para decidir como repartiras tu inversión inicial I0 en los 5 activos. Es decir que quieres decidir sobre los valores αi t con αi t = 1 para t = T+1,...,T + r, en función del rendimiento que esperas de cada activo para el proximo periodo y de una funci´on de utilidad que describe tus preferencias.**

# 2. Predicción de rendimientos
**1. Obten un modelo pronósticos para Xi tXi 0,...,Xt − 1i para i = 1,2,...,5. Utilizando los datos Xtrain como consideres apropiado.**
**2. Obten tanto el valor esperado del pronóstico E[Xi tXi 0,...,Xt − 1i] como la varianza V [Xi tXi 0,...,Xt − 1i].**

**3. en cada momento t = T +1,...,T +r podras utilizar todo el pasado de la serie como 1,...,t − 1 de la forma que consideres adecuado para realizar tu pronostico.**

**4. No veras el periodo de valuación t = T+1,...,T+r hasta después de entregar el proyecto por lo que debes generar un funci´on oneStepAhead(X1:t,Mθ))... return ˆ Xt+1). Es decir que toma el pasado de las 5 series, los modelos de predicción de las 5 series y que regresa un el pronostico a un paso (valor esperado y varianza) de los 5 activos**

1)
```{r}
# Seleccionar 5 primeras columnas numéricas
num_cols <- names(datos)[sapply(datos, is.numeric)]
assets   <- num_cols[1:5]
assets
```

```{r}
# Ajustar modelo ARIMA para cada activo usando TODO el X_train
modelos <- list()

for (asset in assets) {
  serie <- na.omit(datos[[asset]])
  
  # Transformamos la serie a una serie temporal
  serie_ts <- ts(serie)
  
  #Aplicamos la función autoarima
  mod <- auto.arima(serie_ts, stepwise = FALSE,approximation = FALSE)
  
  modelos[[asset]] <- mod
  
  cat("\nModelo para", asset, ":\n")
  print(mod)
}

```

```{r}
oneStepAhead <- function(X_past, modelos) {
  mu  <- numeric(length(modelos))
  sig2 <- numeric(length(modelos))
  
  names(mu)   <- names(modelos)
  names(sig2) <- names(modelos)
  
  for (asset in names(modelos)) {
    serie <- as.numeric(na.omit(X_past[[asset]]))
    serie_ts <- ts(serie)
    
    # Actualizamos usando TODO el pasado disponible
    mod_upd <- Arima(serie_ts, model = modelos[[asset]])
    
    fc <- forecast(mod_upd, h = 1)
    
    mu[asset]   <- as.numeric(fc$mean[1])           # E[X_{t+1} | pasado]
    sig2[asset] <- as.numeric(mod_upd[["sigma2"]]) # Varianza del modelo
  }
  
  return(list(mean = mu, var = sig2))
}

```

```{r}
mod_mv<-oneStepAhead( datos[, assets],modelos)
mod_mv
```

Recordemos que el Modelo 1 es un ARIMA(0,0,0) y nos llama la atención el resultado obtenido por tener media 0 y varianza finita, lo que concuerda con el ruido blanco, .

En resumen: 
```{r}
cat('El valor esperado del modelo X1:', mean(mod_mv$mean[1],na.rm = TRUE))
cat('La varianza del modelo X1:', mean(mod_mv$var[1],na.rm = TRUE))

cat('El valor esperado del modelo X2:', mean(mod_mv$mean[2],na.rm = TRUE))
cat('La varianza del modelo X2:', mean(mod_mv$var[2],na.rm = TRUE))


cat('El valor esperado del modelo X3:', mean(mod_mv$mean[3],na.rm = TRUE))
cat('La varianza del modelo X3:', mean(mod_mv$var[3],na.rm = TRUE))

cat('El valor esperado del modelo X4:', mean(mod_mv$mean[4],na.rm = TRUE))
cat('La varianza del modelo X4:', mean(mod_mv$var[4],na.rm = TRUE))


cat('El valor esperado del modelo X5:', mean(mod_mv$mean[5],na.rm = TRUE))
cat('La varianza del modelo X5:', mean(mod_mv$var[5],na.rm = TRUE))
```

Por otro lado, para que al incorporar los datos reales podamos realizar todas las predicciones mediante el enfoque one step ahead, vamos a crear una función que se actualice progresivamente a medida que se dispone de nueva información, incorporando los valores reales que inicialmente no conocemos.

```{r}
oneStepAhead_mod <- function(X_past, X_reales, modelos, k) {
  
  # lista donde guardamos los pronósticos
  preds <- vector("list", k)
  means_list <- vector("list", k)
  vars_list  <- vector("list", k)
  
  for (i in 1:k) {
    
    # 1. pronóstico one-step-ahead
    pred <- oneStepAhead(X_past, modelos)
    
    # guardar predicción
    preds[[i]] <- pred$mean
    vars_list[[i]]  <- pred$var
    
    # 2. añadir la observación real siguiente (una fila)
    # X_reales debe ser un data frame con 5 columnas
    X_past <- rbind(X_past, X_reales[i, ])
  }
  
  # devolver matriz k x 5 de predicciones
  preds_matrix <- do.call(rbind, preds)
  rownames(preds_matrix) <- paste0("t+", 1:k)
  vars_matrix  <- do.call(rbind, vars_list)
  rownames(vars_matrix)  <- paste0("t+", 1:k)
  
  return(list(mean=preds_matrix,
    var  = vars_matrix))
}

```

Comprobación de la función usando $X_{TRAIN}$ y $X_{TEST}$:

```{r}
N <- nrow(datos)
prop_test <- 0.2

# número de datos para test
r <- round(N * prop_test)

# número de datos para train
T_train <- N - r

X_train <- datos[1:T_train, ]
X_test <- datos[(T_train + 1):N, ]

cat("Tamaño X_train:", nrow(X_train), "\n")
cat("Tamaño X_test:", nrow(X_test), "\n")

```

```{r}
mod_mod<-oneStepAhead_mod(X_train,X_test,modelos,k=24)
mod_mod
```

# Utilidad Media-Varianza

**1. Obtener αt para t = T +1,...,T +r optimizando UMV. Elegir γ y estimar Σt tomando en cuenta que evaluara el rendimiento total en un periodo de prueba. Se permite tomar posiciones cortas**

**2. Repetir pero ahora prohibiendo posiciones cortas.**

```{r}
construccion_sigma_t <- function(X_past, X_reales, modelos, k) {
  
  # 1. Obtener pronósticos y varianzas
  mod_osa <- oneStepAhead_mod(X_past, X_reales, modelos, k)
  vars_matrix <- mod_osa$var       # k x N
  mu_matrix   <- mod_osa$mean      # k x N
  
  N <- ncol(vars_matrix)
  Sigma_list <- vector("list", k)
  
  # Loop para cada paso
  for (i in 1:k) {
    
    var_vector <- vars_matrix[i, ]           # fila i → varianzas predichas
    diagonal_sigmas <- sqrt(as.numeric(var_vector))
    D <- diag(diagonal_sigmas)               # matriz diagonal N×N
    
    # matriz de correlaciones histórica (usando todo X_past hasta ese punto)
    R <- cor(rbind(X_past, X_reales[1:i, ]), use = "pairwise.complete.obs")
    
    # reconstruir Σ_t para el paso i
    Sigma_list[[i]] <- D %*% R %*% D
  }
  
  return(Sigma_list)  # lista de k matrices N×N
}

```


```{r}
#Tenemos que fijar gamma, que es la aversión al riesgo. 
# Valores más altos implican mayor aversión al riesgo (no quieres arriesgar tanto)

UMV <- function(datos, alfat, gamma, mu, var_vector) {
  sigma_t<-construccion_1sigma_t(var_vector,datos)
  
  # 2. CALCULAR EL RENDIMIENTO ESPERADO DEL PORTAFOLIO (E[Rp])
  E_Rp <- t(alfat) %*% mu
  
  
  # 3. CALCULAR LA VARIANZA DEL PORTAFOLIO (Var[Rp])
  Var_Rp <- t(alfat) %*% sigma_t %*% alfat
  
  
  # 4. CALCULAR LA UTILIDAD ESPERADA (U)
  U <- E_Rp - (1/2) * gamma * Var_Rp
  
  return(as.numeric(U))
}
```

```{r}
posiciones_cortas <- function(X_past, X_reales, modelos, k, gamma) {
  
  # 1. Pronósticos one-step-ahead (sin cambios, asumiendo que ya corrigiste $means por $mean)
  mod_osa <- oneStepAhead_mod(X_past, X_reales, modelos, k)
  mu_matrix  <- as.matrix(mod_osa$mean)  # k x N
  var_matrix <- as.matrix(mod_osa$var)   # k x N
  
  N <- ncol(mu_matrix)
  uno <- matrix(1, nrow = 1, ncol = N)    # Vector de unos (1 x N)
  
  # 2. Matrices de covarianza para cada paso (sin cambios)
  Sigma_list <- construccion_sigma_t(X_past, X_reales, modelos, k)  # lista de k matrices N x N
  
  alphas <- vector("list", k)
  
  for (i in 1:k) {
    
    mu <- matrix(mu_matrix[i, ], ncol = 1)      # vector mu (N x 1)
    Sigma_t <- Sigma_list[[i]]                  # matriz Sigma (N x N)
    Sigma_inv <- solve(Sigma_t)
    
    # Componentes A y B (sin cambios, son correctas para cualquier gamma)
    A <- as.numeric(uno %*% Sigma_inv %*% t(uno))  # A = 1' * Sigma_inv * 1
    B <- as.numeric(uno %*% Sigma_inv %*% mu)      # B = 1' * Sigma_inv * mu
    
    # --- CAMBIO CRÍTICO: Cálculo de lambda ---
    # Calculamos el multiplicador de Lagrange original (lambda_star), 
    # que es función de gamma: lambda* = (B - gamma) / A
    lambda_star <- (B - gamma) / A 
    
    # 1. Parte por rendimiento/riesgo
    # (1/gamma) * Sigma_inv * mu
    parte_mu <- (1/gamma) * (Sigma_inv %*% mu)
    
    # 2. Parte de la restricción (ajustada por gamma)
    # (lambda*/gamma) * Sigma_inv * 1
    lambda_factor <- lambda_star / gamma # Factor que acompaña a Sigma_inv * 1
    parte_restriccion <- Sigma_inv %*% t(uno) * lambda_factor
    
    # La posición óptima (alpha) es la resta de las dos partes:
    # alpha = (1/gamma) * Sigma_inv * mu - (lambda*/gamma) * Sigma_inv * 1
    alpha <- parte_mu - parte_restriccion
    alphas[[i]] <- as.numeric(alpha)
  }
  
  # Resultado final (sin cambios)
  alphas_matrix <- do.call(rbind, alphas)
  rownames(alphas_matrix) <- paste0("t+", 1:k)
  colnames(alphas_matrix) <- colnames(mu_matrix) # Usar nombres de activos
  
  return(alphas_matrix)
}

```

```{r}
# Supongamos que ya tienes X_train, X_test y modelos ajustados
alphas_optimos <- posiciones_cortas(
  X_past = X_train,
  X_reales = X_test,
  modelos = modelos,
  k = 5,       # número de pasos a pronosticar
  gamma = 5    # aversión al riesgo
)

# Mostrar resultados
print(alphas_optimos)

suma_filas <- rowSums(alphas_optimos)
print(suma_filas)
```

```{r}
sin_posiciones_cortas<-function(){
  
}
```

