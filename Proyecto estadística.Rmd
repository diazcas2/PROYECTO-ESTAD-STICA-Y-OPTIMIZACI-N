---
title: "Proyecto estadística"
author: "María de los Ángeles Díaz Castro, Florencia Pellegrini, Iyán Álvarez Rodriguez, Azahara Martinez Moraño"
date: "2025-12-01"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(readr)
library(forecast)   
library(tseries)    
library(ggplot2)
library(gridExtra)
library(dplyr)
library(jsonlite)

datos <- read_csv("stock_returns_train.csv")
```

# 1. Planteamiento
**Tu equipo ha decidido invertir en un portafolio con 5 activos. Cuentas con un historico de rendimientos ri t para t = 1,...,T y i = 1,...,5 . Quieres usar este histórico para decidir como repartiras tu inversión inicial I0 en los 5 activos. Es decir que quieres decidir sobre los valores αi t con αi t = 1 para t = T+1,...,T + r, en función del rendimiento que esperas de cada activo para el proximo periodo y de una funci´on de utilidad que describe tus preferencias.**

# 2. Predicción de rendimientos
**1. Obten un modelo pronósticos para Xi tXi 0,...,Xt − 1i para i = 1,2,...,5. Utilizando los datos Xtrain como consideres apropiado.**
**2. Obten tanto el valor esperado del pronóstico E[Xi tXi 0,...,Xt − 1i] como la varianza V [Xi tXi 0,...,Xt − 1i].**

**3. en cada momento t = T +1,...,T +r podras utilizar todo el pasado de la serie como 1,...,t − 1 de la forma que consideres adecuado para realizar tu pronostico.**

**4. No veras el periodo de valuación t = T+1,...,T+r hasta después de entregar el proyecto por lo que debes generar un funci´on oneStepAhead(X1:t,Mθ))... return ˆ Xt+1). Es decir que toma el pasado de las 5 series, los modelos de predicción de las 5 series y que regresa un el pronostico a un paso (valor esperado y varianza) de los 5 activos**

1)

```{r}
oneStepAhead <- function(X_train, X_test_past) {
  # Seleccionar primeras 5 columnas numéricas
  num_cols <- names(X_train)[sapply(X_train, is.numeric)]
  assets   <- num_cols[1:5]
  
  mu_hat_list <- numeric(length(assets))
  se_hat_list <- numeric(length(assets))
  names(mu_hat_list) <- names(se_hat_list) <- assets
  
  for (asset in assets) {
    x_train <- as.numeric(na.omit(X_train[[asset]]))
    x_test_past_asset <- as.numeric(na.omit(X_test_past[[asset]]))
    
    # 1. Ajustar modelo ARIMA sobre el histórico de entrenamiento
    mod <- auto.arima(x_train, stepwise = FALSE, approximation = FALSE)
    
    # 2. Actualizar el modelo con todo el histórico disponible
    x_past <- c(x_train, x_test_past_asset)
    fit_upd <- Arima(x_past, model = mod)
    
    # 3. Forecast one-step-ahead
    fc <- forecast(fit_upd, h = 1)
    mu_hat <- as.numeric(fc$mean[1])
    
    # 4. Estimar error estándar a partir del intervalo del 80%
    z80 <- qnorm(0.8)
    se_from_up <- (fc$upper[,"80%"][1] - fc$mean[1]) / z80
    se_from_lo <- (fc$mean[1] - fc$lower[,"80%"][1]) / z80
    se_hat <- as.numeric(pmax(se_from_up, se_from_lo))
    
    # Guardar resultados
    mu_hat_list[asset] <- mu_hat
    se_hat_list[asset] <- se_hat
  }
  
  return(list(mu_hat = mu_hat_list, se_hat = se_hat_list))
}


```

Comprobación de la función usando $X_{TRAIN}$ y $X_{TEST}$:

```{r}
N <- nrow(datos)
prop_test <- 0.2

# número de datos para test
r <- round(N * prop_test)

# número de datos para train
T_train <- N - r

X_train <- datos[1:T_train, ]
X_test <- datos[(T_train + 1):N, ]

cat("Tamaño X_train:", nrow(X_train), "\n")
cat("Tamaño X_test:", nrow(X_test), "\n")

```

```{r}
mod_mod<-oneStepAhead(X_train,X_test)
mod_mod
```

# Utilidad Media-Varianza

**1. Obtener αt para t = T +1,...,T +r optimizando UMV. Elegir γ y estimar Σt tomando en cuenta que evaluara el rendimiento total en un periodo de prueba. Se permite tomar posiciones cortas**

**2. Repetir pero ahora prohibiendo posiciones cortas.**

```{r}
construccion_sigma_t <- function(X_past, X_reales) {
  N <- ncol(X_past)
  k <- nrow(X_reales)           # número de pasos a predecir
  Sigma_list <- vector("list", k)
  
  # Loop para cada paso
  for (i in 1:k) {
    # 1. Seleccionar la fila actual de X_reales
    X_test_past <- X_reales[i, , drop = FALSE]
    
    # 2. Obtener pronóstico y error estándar usando oneStepAhead_et
    pred <- oneStepAhead(X_past, X_test_past)
    
    # 3. Construir matriz diagonal de desviaciones estándar
    diagonal_sigmas <- pred$se_hat
    D <- diag(diagonal_sigmas)
    
    # 4. Matriz de correlaciones histórica usando todo el pasado hasta este punto
    R <- cor(rbind(X_past, X_reales[1:i, ]), use = "pairwise.complete.obs")
    
    # 5. Reconstruir Σ_t para el paso i
    Sigma_list[[i]] <- D %*% R %*% D
    
    # 6. Actualizar X_past con la observación real de este paso
    X_past <- rbind(X_past, X_test_past)
  }
  
  return(Sigma_list)  # lista de matrices N×N, una por cada fila de X_reales
}
```


```{r}
#Tenemos que fijar gamma, que es la aversión al riesgo. 
# Valores más altos implican mayor aversión al riesgo (no quieres arriesgar tanto)

UMV <- function(datos, alfat, gamma, mu, var_vector) {
  sigma_t<-construccion_1sigma_t(var_vector,datos)
  
  # 2. CALCULAR EL RENDIMIENTO ESPERADO DEL PORTAFOLIO (E[Rp])
  E_Rp <- t(alfat) %*% mu
  
  
  # 3. CALCULAR LA VARIANZA DEL PORTAFOLIO (Var[Rp])
  Var_Rp <- t(alfat) %*% sigma_t %*% alfat
  
  
  # 4. CALCULAR LA UTILIDAD ESPERADA (U)
  U <- E_Rp - (1/2) * gamma * Var_Rp
  
  return(as.numeric(U))
}
```

```{r}

posiciones_cortas <- function(X_past, X_reales, gamma) {
  N <- ncol(X_past)
  uno <- matrix(1, nrow = 1, ncol = N)
  
  # Seleccionar la fila de X_reales para un solo paso
  X_test_past <- X_reales[1, , drop = FALSE]
  
  # Pronóstico one-step-ahead
  pred <- oneStepAhead(X_past, X_test_past)
  mu <- matrix(pred$mean, ncol = 1)
  
  # Matriz de covarianza
  Sigma_list <- construccion_sigma_t(X_past, X_test_past)
  Sigma_t <- Sigma_list[[1]]
  Sigma_inv <- solve(Sigma_t)
  
  # Cálculo de alpha
  A <- as.numeric(uno %*% Sigma_inv %*% t(uno))
  B <- as.numeric(uno %*% Sigma_inv %*% mu)
  lambda_star <- (B - gamma) / A
  
  parte_mu <- (1 / gamma) * (Sigma_inv %*% mu)
  parte_restriccion <- Sigma_inv %*% t(uno) * (lambda_star / gamma)
  alpha <- parte_mu - parte_restriccion
  
  alpha_vec <- as.numeric(alpha)
  names(alpha_vec) <- colnames(X_past)
  
  return(alpha_vec)
}


```

```{r}
# Supongamos que ya tienes X_train, X_test y modelos ajustados
alphas_optimos <- posiciones_cortas(
  X_past = X_train,
  X_reales = X_test,
  gamma = 5    # aversión al riesgo
)

# Mostrar resultados
print(alphas_optimos)
sum(alphas_optimos)

```

```{r}
library(quadprog)
sin_posiciones_cortas <- function(X_past, X_reales, gamma) {
  # Número de activos
  N <- ncol(X_past)
  
  # Seleccionar la fila actual de X_reales (solo un paso ahead)
  X_test_past <- X_reales[1, , drop = FALSE]
  
  # 1. Pronóstico one-step-ahead
  pred <- oneStepAhead(X_past, X_test_past)
  mu <- as.numeric(pred$mean)
  
  # 2. Matriz de covarianza
  Sigma_list <- construccion_sigma_t(X_past, X_test_past)
  Sigma_t <- Sigma_list[[1]]
  
  # 3. Definir parámetros para solve.QP
  Dmat <- gamma * Sigma_t
  dvec <- mu
  Aeq <- matrix(1, nrow = N, ncol = 1)
  G <- diag(N)
  Amat <- cbind(Aeq, G)
  bvec <- c(1, rep(0, N))
  
  # 4. Resolver problema de optimización cuadrática
  sol <- quadprog::solve.QP(Dmat, dvec, Amat, bvec, meq = 1)
  
  # 5. Ajustes finales: redondear y eliminar negativos
  alpha_vec <- round(sol$solution, 8)
  alpha_vec[alpha_vec < 0] <- 0
  names(alpha_vec) <- colnames(X_past)
  
  return(alpha_vec)
}


```


```{r}
alphas_sin_cortos <- sin_posiciones_cortas(
  X_past = X_train,
  X_reales = X_test,
  gamma = 5
)

print(alphas_sin_cortos)
sum(alphas_sin_cortos)
alphas_sin_cortos < 0

```


# Log-utilidad

**1. Obtener αt para t = T +1,...,T +r optimizando Ulog. Se permite tomar posiciones cortas y no enteras.**

```{r}
Ulog_neg <- function(alpha, mu, Sigma, gamma){
  
  alpha <- as.numeric(alpha)  # asegurar que es vector
  Sigma <- as.matrix(Sigma)   # asegurar que es matriz
  
  if(1 + sum(alpha * mu) <= 0){
    return(1e6)
  }
  
  term1 <- log(1 + sum(alpha * mu))
  term2 <- (gamma / 2) * var_p / (1 + alpha_mu)^2
  U <- term1 - term2
  
  return(-as.numeric(U))
}

```

```{r}
restriccion <- function(alpha){
  return( (sum(alpha) - 1)^2 * 1e3 )  # penalización fuerte
}

```

```{r}
optimizar_log <- function(X_past, X_reales, gamma){
  
  # Solo usa el siguiente paso
  X_test_past <- X_reales[1, , drop = FALSE]
  
  # Pronóstico
  pred <- oneStepAhead(X_past, X_test_past)
  mu <- as.numeric(pred$mu_hat)
  
  # Matriz de covarianza
  Sigma_t <- construccion_sigma_t(X_past, X_test_past)[[1]]
  Sigma_t <- as.matrix(Sigma_t)
  if(length(dim(Sigma_t)) == 3) Sigma_t <- Sigma_t[1,,]  # corregir 3D a 2D
  
  # Inicialización: pesos iguales
  N <- length(mu)
  alpha0 <- rep(1/N, N)
  
  # Restricción sum(alpha)=1 ---> penalización
  restriccion <- function(alpha){
    return( (sum(alpha) - 1)^2 * 1e3 )
  }
  
  obj <- function(alpha){
    Ulog_neg(alpha, mu, Sigma_t, gamma) + restriccion(alpha)
  }
  
  sol <- optim(alpha0, obj, method = "BFGS", control = list(maxit = 1000))
  
  # Normalizar para corregir errores numéricos
  alpha_opt <- sol$par / sum(sol$par)
  names(alpha_opt) <- colnames(X_past)
  
  return(alpha_opt)
}


```


```{r}
alpha_log <- optimizar_log(
  X_past = X_train,
  X_reales = X_test,
  gamma = 5   # tu aversión al riesgo
)

alpha_log
sum(alpha_log)  # debe ser ≈ 1

```

