---
title: "Proyecto estadística"
author: "María de los Ángeles Díaz Castro, Florencia Pellegrini, Iyán Álvarez Rodriguez, Azahara Martinez Moraño"
date: "2025-12-01"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(readr)
library(forecast)   
library(tseries)    
library(ggplot2)
library(gridExtra)
library(dplyr)
library(jsonlite)

datos <- read_csv("stock_returns_train.csv")
```

# 1. Planteamiento
**Tu equipo ha decidido invertir en un portafolio con 5 activos. Cuentas con un historico de rendimientos ri t para t = 1,...,T y i = 1,...,5 . Quieres usar este histórico para decidir como repartiras tu inversión inicial I0 en los 5 activos. Es decir que quieres decidir sobre los valores αi t con αi t = 1 para t = T+1,...,T + r, en función del rendimiento que esperas de cada activo para el proximo periodo y de una funci´on de utilidad que describe tus preferencias.**

# 2. Predicción de rendimientos
**1. Obten un modelo pronósticos para Xi tXi 0,...,Xt − 1i para i = 1,2,...,5. Utilizando los datos Xtrain como consideres apropiado.**
**2. Obten tanto el valor esperado del pronóstico E[Xi tXi 0,...,Xt − 1i] como la varianza V [Xi tXi 0,...,Xt − 1i].**

**3. en cada momento t = T +1,...,T +r podras utilizar todo el pasado de la serie como 1,...,t − 1 de la forma que consideres adecuado para realizar tu pronostico.**

**4. No veras el periodo de valuación t = T+1,...,T+r hasta después de entregar el proyecto por lo que debes generar un funci´on oneStepAhead(X1:t,Mθ))... return ˆ Xt+1). Es decir que toma el pasado de las 5 series, los modelos de predicción de las 5 series y que regresa un el pronostico a un paso (valor esperado y varianza) de los 5 activos**

1)
```{r}
# Seleccionar 5 primeras columnas numéricas
num_cols <- names(datos)[sapply(datos, is.numeric)]
assets   <- num_cols[1:5]
assets
```

```{r}
# Ajustar modelo ARIMA para cada activo usando TODO el X_train
modelos <- list()

for (asset in assets) {
  serie <- na.omit(datos[[asset]])
  
  # Transformamos la serie a una serie temporal
  serie_ts <- ts(serie)
  
  #Aplicamos la función autoarima
  mod <- auto.arima(serie_ts, stepwise = FALSE,approximation = FALSE)
  
  modelos[[asset]] <- mod
  
  cat("\nModelo para", asset, ":\n")
  print(mod)
}

```

```{r}
oneStepAhead <- function(X_past, modelos) {
  mu  <- numeric(length(modelos))
  sig2 <- numeric(length(modelos))
  
  names(mu)   <- names(modelos)
  names(sig2) <- names(modelos)
  
  for (asset in names(modelos)) {
    serie <- as.numeric(na.omit(X_past[[asset]]))
    serie_ts <- ts(serie)
    
    # Actualizamos usando TODO el pasado disponible
    mod_upd <- Arima(serie_ts, model = modelos[[asset]])
    
    fc <- forecast(mod_upd, h = 1)
    
    mu[asset]   <- as.numeric(fc$mean[1])           # E[X_{t+1} | pasado]
    sig2[asset] <- as.numeric(mod_upd[["sigma2"]]) # Varianza del modelo
  }
  
  return(list(mean = mu, var = sig2))
}

```

```{r}
mod_mv<-oneStepAhead( datos[, assets],modelos)
mod_mv
```

Recordemos que el Modelo 1 es un ARIMA(0,0,0) y nos llama la atención el resultado obtenido por tener media 0 y varianza finita, lo que concuerda con el ruido blanco, .

En resumen: 
```{r}
cat('El valor esperado del modelo X1:', mean(mod_mv$mean[1],na.rm = TRUE))
cat('La varianza del modelo X1:', mean(mod_mv$var[1],na.rm = TRUE))

cat('El valor esperado del modelo X2:', mean(mod_mv$mean[2],na.rm = TRUE))
cat('La varianza del modelo X2:', mean(mod_mv$var[2],na.rm = TRUE))


cat('El valor esperado del modelo X3:', mean(mod_mv$mean[3],na.rm = TRUE))
cat('La varianza del modelo X3:', mean(mod_mv$var[3],na.rm = TRUE))

cat('El valor esperado del modelo X4:', mean(mod_mv$mean[4],na.rm = TRUE))
cat('La varianza del modelo X4:', mean(mod_mv$var[4],na.rm = TRUE))


cat('El valor esperado del modelo X5:', mean(mod_mv$mean[5],na.rm = TRUE))
cat('La varianza del modelo X5:', mean(mod_mv$var[5],na.rm = TRUE))
```

# Utilidad Media-Varianza

**1. Obtener αt para t = T +1,...,T +r optimizando UMV. Elegir γ y estimar Σt tomando en cuenta que evaluara el rendimiento total en un periodo de prueba. Se permite tomar posiciones cortas**

**2. Repetir pero ahora prohibiendo posiciones cortas.**

```{r}
construccion_sigma_t<-function(var,datos){
  diagonal_sigmas <- sqrt(var)
  D <- diag(diagonal_sigmas)
  R <- cor(datos)
  
  # Reconstruir la Matriz de Covarianzas Sigma_t
  sigma_t <- D %*% R %*% D
  return(sigma_t)
}
```


```{r}
#Tenemos que fijar gamma, que es la aversión al riesgo. 
# Valores más altos implican mayor aversión al riesgo (no quieres arriesgar tanto)

UMV <- function(datos, alfat, gamma, mu, var_vector) {
  construccion_sigma_t<-sigma_t(var_vector,datos)
  
  # 2. CALCULAR EL RENDIMIENTO ESPERADO DEL PORTAFOLIO (E[Rp])
  E_Rp <- t(alfat) %*% mu
  
  
  # 3. CALCULAR LA VARIANZA DEL PORTAFOLIO (Var[Rp])
  Var_Rp <- t(alfat) %*% sigma_t %*% alfat
  
  
  # 4. CALCULAR LA UTILIDAD ESPERADA (U)
  U <- E_Rp - (1/2) * gamma * Var_Rp
  
  return(as.numeric(U))
}
```

```{r}
posiciones_cortas <- function(mu, sigma_t, gamma) {
  
  # Inversa de Sigma
  sigma_t_inv <- solve(sigma_t) 
  
  # Vector de unos
  n <- length(mu) 
  vectorde1 <- matrix(1, n, 1)
  
  # 1. Constantes escalares
  A <- t(vectorde1) %*% sigma_t_inv %*% vectorde1
  B <- t(vectorde1) %*% sigma_t_inv %*% mu
  
  # 2. Parte sin restricción
  parte_mu <- (1 / gamma) * (sigma_t_inv %*% mu)
  
  # 3. Lagrange
  lambda <- (B - gamma) / (gamma * A)
  
  # 4. Ajuste por restricción de suma 1
  parte_restriccion <- lambda * (sigma_t_inv %*% vectorde1)
  
  # 5. Solución final
  alpha_optimo <- parte_mu - parte_restriccion
  
  return(as.numeric(alpha_optimo)) 
}

```

```{r}
posiciones_cortas(
  mu = mod_mv$mean,
  sigma_t = construccion_sigma_t(mod_mv$var,datos),
  gamma = 5
)
```


